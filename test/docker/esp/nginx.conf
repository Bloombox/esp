daemon off;

worker_processes auto;

events {
  worker_connections 4096;
  multi_accept on;
}

error_log /var/log/nginx/error.log debug;

http {
  include mime.types;
  server_tokens off;

  # set max body size to 32m as appengine supports.
  client_max_body_size 32m;

  tcp_nodelay on;
  tcp_nopush on;

  keepalive_requests 10000;

  upstream app_server {
    server gaeapp:8080;
  }
  upstream flex_agent {
    server 127.0.0.1:8000;
  }

  upstream metadata_server {
    server metadata:8080;
  }

  upstream service_control {
    server control:8080;
  }

  geo $source_type {
    default ext;
    127.0.0.0/8 lo;
    169.254.0.0/16 sb;
    130.211.0.0/22 lb;
    172.16.0.0/12 do;
  }

  endpoints {
    metadata_server http://metadata_server;
  }

  server {
    # Running port
    listen 8080;

    # Allow more space for request headers.
    large_client_header_buffers 4 16k;

    # If request comes from lo or sb, do not care about x-forwarded-for header.
    if ($source_type !~ sb|lo|do) {
      set $x_forwarded_for_test $http_x_forwarded_for;
    }

    # For local health checks only.
    if ($http_x_google_vme_health_check = 1) {
      set $x_forwarded_for_test "";
    }

    # If the request does not come from sb, reject if it did not pass through
    # the appengine pipeline (10.0.0.0/8)
    if ($x_forwarded_for_test !~ '(?:^$)|(?:\b10\.\d+\.\d+\.\d+,\s*\d+(?:\.\d+){3}$)') {
      # Nginx custom status code: drop the request with no response.
      return 444;
    }

    location / {

      endpoints {
        on;
        api /app/endpoints/service.json;
      }

      include /var/lib/nginx/inc/proxy_pass.inc;
      proxy_set_header X-Endpoint-API-UserInfo $endpoints_api_userinfo;

      location = /_ah/health {
        endpoints { off; }
        if ($http_x_google_vme_health_check = 1) {
          proxy_pass http://app_server;
          break;
        }
        proxy_pass http://flex_agent;
      }

      location = /_ah/vm_health {
        endpoints { off; }
        proxy_pass http://flex_agent;
      }
    }

    include /var/lib/nginx/extra/*.conf;
  }

  server {
    # expose /nginx_status but on a different port (8090) to avoid
    # external visibility / conflicts with the app.
    listen 8090;

    location /nginx_status {
      stub_status on;
      access_log off;
    }

    location / {
      root /dev/null;
    }
  }

  # Output nginx access logs in the standard format, plus an additional
  # field containing the "X-Cloud-Trace-Context" header at the end.
  log_format tracecontext '$remote_addr - $remote_user [$time_local] '
                          '"$request" $status $body_bytes_sent '
                          '"$http_referer" "$http_user_agent" '
                          'tracecontext="$http_x_cloud_trace_context"';

  access_log /var/log/nginx/access.log tracecontext;
}
